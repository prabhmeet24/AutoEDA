# -*- coding: utf-8 -*-
"""bivariate_class.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1izeU777u799BCwNXeZmfcdciY9vxstty
"""

import pandas as pd
import numpy as np
from prettytable import PrettyTable
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
from scipy.stats import chi2_contingency
from IPython.display import display
from scipy import stats
from sklearn.preprocessing import LabelEncoder

class BivariateAnalysis:

    def __init__(self, df, num_columns=None, cat_columns=None):
        self.df = df
        if num_columns is None:
            self.num_cols = pd.DataFrame({})
        else:
            self.num_cols = df[num_columns]

        if cat_columns is None:
            self.cat_cols = pd.DataFrame({})
        else:
            self.cat_cols = df[cat_columns]

    def cramers_v(self, x, y):
        confusion_matrix = pd.crosstab(x, y)
        chi2 = chi2_contingency(confusion_matrix)[0]
        n = confusion_matrix.sum().sum()
        phi2 = chi2 / n
        r, k = confusion_matrix.shape
        phi2corr = max(0, phi2 - ((k - 1) * (r - 1)) / (n - 1))
        rcorr = r - ((r - 1) ** 2) / (n - 1)
        kcorr = k - ((k - 1) ** 2) / (n - 1)
        return np.sqrt(phi2corr / min((kcorr - 1), (rcorr - 1)))

    def bivariate(self, top_n=10, cat_corr_value=0.2, num_corr_value=0.4):
        if self.df.empty:
            raise ValueError("The dataframe is empty. No analysis can be carried out")

        with warnings.catch_warnings():
            warnings.simplefilter("ignore")

            plotted_combinations = set()

            print("\033[1mAnalysis of categorical columns\033[0m")

            # Iterate over specified categorical columns
            for column in self.cat_cols.columns:
                unique_values = self.cat_cols[column].unique()
                num_unique_values = len(unique_values)
                total_values = len(self.cat_cols[column])
                threshold_percentage = 0.05

                # Check conditions for including the column in analysis
                if (
                    num_unique_values / total_values < threshold_percentage
                    or self.cat_cols[column].dtype in ['object', 'bool']
                ):
                    value_counts = self.cat_cols[column].value_counts()

                    if len(value_counts) > top_n:
                        value_counts = value_counts.head(top_n)

                    # Iterate over specified categorical columns
                    for other_column in self.cat_cols.columns:
                        if other_column != column:
                            # Calculate Cramér's V for categorical columns
                            cramer_v = self.cramers_v(self.cat_cols[column], self.cat_cols[other_column])

                            if cramer_v > cat_corr_value:
                                crosstab = pd.crosstab(
                                    self.cat_cols[column], self.cat_cols[other_column], normalize='index'
                                ).mul(100).round(2)
                                counts = self.df.groupby([column, other_column]).size().unstack(fill_value=0)

                                if len(counts) > top_n:
                                    counts = counts.head(top_n)

                                fig, axes = plt.subplots(1, 2, figsize=(14, 6))

                                counts.plot(kind='bar', stacked=True, ax=axes[0])
                                axes[0].set_title(f"{column} vs {other_column} - Bar Plot")

                                counts.plot(kind='area', stacked=True, ax=axes[1])
                                axes[1].set_title(f"{column} vs {other_column} - Area Plot")

                                top_n_categories = value_counts.index.tolist()
                                filtered_df = self.df[self.df[column].isin(top_n_categories)]
                                plt.figure(figsize=(12, 6))
                                sns.violinplot(x=filtered_df[column], y=filtered_df[other_column])
                                plt.xlabel(column)
                                plt.ylabel(other_column)
                                plt.title(f"Violin Plot - {column} vs {other_column}")

                                plt.tight_layout()
                                plt.show()

                                if len(crosstab) > top_n:
                                    crosstab = crosstab.head(top_n)
                                display(crosstab)

                                print(f"\033[1mCramér's V between {column} and {other_column}:\033[0m {cramer_v:.2f}")

            print("\033[1mAnalysis of numerical columns\033[0m")

            # Iterate over specified numerical columns
            for column in self.num_cols.columns:
                for other_column in self.num_cols.columns:
                    if other_column != column:
                        combination = frozenset([column, other_column])
                        if combination not in plotted_combinations:
                            plotted_combinations.add(combination)
                            plotted_combinations.add(frozenset([other_column, column]))

                            correlation = self.num_cols[column].corr(self.num_cols[other_column])
                            if correlation > num_corr_value:

                                x_values = self.num_cols[column]
                                y_values = self.num_cols[other_column]

                                plt.figure(figsize=(18, 9))
                                plt.subplot(2, 5, 1)
                                plt.scatter(x_values, y_values)
                                plt.xlabel(column)
                                plt.ylabel(other_column)

                                plt.subplot(2, 5, 2)
                                plt.hexbin(x_values, y_values)
                                plt.xlabel(column)
                                plt.ylabel(other_column)

                                plt.subplot(2, 5, 3)
                                sns.histplot(data=self.df, x=x_values, y=y_values, bins=(4, 4), cmap='Blues', cbar=True)
                                plt.xlabel(column)
                                plt.ylabel(other_column)

                                g = sns.pairplot(self.df[[column, other_column]], height=3)
                                g.fig.suptitle(f"Pairplot of {column} and {other_column}")
                                g.fig.set_size_inches(18, 9)

                                plt.show()

    def get_most_correlated_column(self, target_column):
        most_corr_column = None
        max_corr_strength = 0

        for other_column in self.cat_cols.columns:
            if other_column != target_column:
                cramer_v = self.cramers_v(self.cat_cols[target_column], self.cat_cols[other_column])

                if cramer_v > max_corr_strength:
                    most_corr_column = other_column
                    max_corr_strength = cramer_v

        return most_corr_column, max_corr_strength

    def num_to_cat_analysis(self, filter=False, corr_value=0.00):
        label = LabelEncoder()
        for column in self.cat_cols:
            self.df[column] = label.fit_transform(self.df[column])
        for cat_column in self.cat_cols.columns:
            for num_column in self.num_cols.columns:
                corr = self.df[cat_column].corr(self.df[num_column])
                if corr>=corr_value:
                  plt.figure(figsize=(20, 10))
                  plt.subplot(1, 3, 1)
                  sns.scatterplot(x=self.cat_cols[cat_column], y=self.df[num_column])
                  plt.xlabel(cat_column)
                  plt.ylabel(num_column)
                  plt.xticks(rotation='vertical')
                  plt.title(f"Correlation between {cat_column} and {num_column}")

                  plt.subplot(1, 3, 2)
                  sns.violinplot(x=self.cat_cols[cat_column], y=self.df[num_column])
                  plt.xlabel(cat_column)
                  plt.ylabel(num_column)
                  plt.xticks(rotation='vertical')
                  plt.title(f"Violin plot of {num_column} by {cat_column}")

                  plt.subplot(1, 3, 3)
                  sns.barplot(x=self.cat_cols[cat_column],y=self.df[num_column])
                  plt.xlabel(cat_column)
                  plt.ylabel(num_column)
                  plt.title(f"BarPlot between {num_column} by {cat_column}")
                  plt.xticks(rotation='vertical')
                  plt.show()
        plt.figure(figsize=(20, 10))
        sns.heatmap(self.df[self.num_cols.columns].corr(), annot=True, cmap="coolwarm", fmt=".2f")
        plt.title("Total Correlation")

    def show_report(self):
        num_table = PrettyTable(field_names=['Column Name', 'Dtype', 'Most Correlation', 'Correlation Strength(in %)'])
        cat_table = PrettyTable(field_names=['Column Name', 'Dtype', 'Most Correlation', 'Correlation Strength(in %)'])

        for column in self.num_cols.columns:
            dtype = self.num_cols[column].dtype
            correlation_matrix = self.num_cols.corr().abs().unstack()
            correlation_matrix = correlation_matrix.sort_values(ascending=False)
            correlation_matrix = correlation_matrix[correlation_matrix.index.get_level_values(0) != column]
            most_corr_column = correlation_matrix.idxmax()[0]
            strength = self.num_cols[column].corr(self.num_cols[most_corr_column])
            num_table.add_row([column, dtype, most_corr_column, f'{round((strength*100), 2)}%'])

        for column in self.cat_cols.columns:
            dtype = self.cat_cols[column].dtype
            most_corr_column, corr_strength = self.get_most_correlated_column(column)
            cat_table.add_row([column, dtype, most_corr_column, f'{round((corr_strength*100),2)} %'])

        print(num_table)
        print(cat_table)